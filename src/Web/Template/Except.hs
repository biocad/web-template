{-# LANGUAGE DeriveGeneric             #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleInstances         #-}
{-# LANGUAGE MonoLocalBinds            #-}
{-# LANGUAGE OverloadedStrings         #-}
{-# LANGUAGE RecordWildCards           #-}
{-# LANGUAGE StandaloneDeriving        #-}

module Web.Template.Except
  (
    Except (..)
  , JsonWebError (..)
  , ScottyError (..)
  , handleEx
  , MonadWebError(..)
  , ExceptionFormatter
  , logExceptionWith
  , logException
  ) where

import           Control.Exception         (Exception (..), SomeException)
import           Control.Monad.Catch       (MonadCatch, catch)
import           Data.Aeson                (FromJSON (..), Object, ToJSON (..),
                                            defaultOptions, genericToEncoding,
                                            (.=))
import           Data.String               (fromString)
import           Data.Text                 (Text, pack)
import           GHC.Generics              (Generic)
import           GHC.Stack
import           Network.HTTP.Types.Status (Status, status403, status404,
                                            status500)
import           System.BCD.Log            (MonadBCDLog (..), WithBCDLog)
import           Web.Scotty.Trans          (ActionT, ScottyError (..), json,
                                            raise, status)

instance ScottyError Except where
    stringError = JsonException
    showError = fromString . show

data Except
  = Forbidden
  | NotFound !Int
  | StringException !String
  | JsonException !String
  | forall a. (Show a, ToJSON a) => CustomJsonException { cStatus :: !Status, cError :: !a }

deriving instance Show Except

newtype JsonWebError = JsonWebError { error :: String }
  deriving (Generic)

instance ToJSON JsonWebError where
  toEncoding = genericToEncoding defaultOptions
instance FromJSON JsonWebError

handleEx :: Monad m => Except -> ActionT Except m ()
handleEx Forbidden = do
    status status403
    json . JsonWebError $ "Forbidden from server"
handleEx (NotFound i) = do
    status status404
    json . JsonWebError $ "Can't find " ++ show i
handleEx (StringException str)  = do
    status status500
    json . JsonWebError $ "Server problem: " ++ str
handleEx (JsonException str)  = do
    status status500
    json . JsonWebError $ str
handleEx CustomJsonException{..} = do
    status cStatus
    json cError

-- | MTL-style type class for monads that can throw user-visible HTTP errors.
--
class MonadWebError m where
  -- | Throw any 'ToJSON'able value with custom HTTP code. The value will be sent
  -- directly as response without any additional formatting.
  --
  throwJson :: (Show e, ToJSON e) => Status -> e -> m a

  -- | Specialized version of 'throwJson' that uses @500 Internal Server Error@ code.
  {-# INLINE throwJson500 #-}
  throwJson500 :: (Show e, ToJSON e) => e -> m a
  throwJson500 = throwJson status500

instance Monad m => MonadWebError (ActionT Except m) where
  {-# INLINE throwJson #-}
  throwJson s e = raise $ CustomJsonException s e

type ExceptionFormatter e a = e -> a

defaultExceptionFormatter :: ExceptionFormatter SomeException Object
defaultExceptionFormatter _ = "error" .= ("error.exception" :: Text)

handler500
  :: (Monad m, WithBCDLog m, MonadWebError m, Exception e, Show r, ToJSON r)
  => Text
  -> ExceptionFormatter e r
  -> e -> m a
handler500 appName formatter e = withFrozenCallStack $ do
    logError appName $ pack $ displayException e
    throwJson500 $ formatter e

-- | Run an action, typically a 'Web.Template.Types.WebM', catching all exceptions it may throw.
--
-- Exceptions will be logged fully to the logger and route will return @500 Internal Server Error@
-- with JSON message generated by the formatter.
--
-- Since the formatter is polymorphic in exception type, you can control which exception types
-- to catch, as with 'Control.Exception.catch' from @Control.Exception@.
--
-- It's recommended to avoid sending all exception's detail to users for security reasons.
--
{-# INLINE logExceptionWith #-}
logExceptionWith
  :: (MonadWebError m, MonadCatch m, WithBCDLog m, Exception e, Show r, ToJSON r)
  => Text                   -- ^ Application name
  -> ExceptionFormatter e r -- ^ Formatter for exceptions
  -> m a                    -- ^ Action to run
  -> m a
logExceptionWith appName formatter action =
  withFrozenCallStack $ catch action $ handler500 appName formatter

-- | Specialized version of 'logExceptionWith'. This wrapper will catch all exceptions
-- (via 'SomeException') and return this JSON:
--
-- @
-- {"error": "error.exception"}
-- @
--
{-# INLINE logException #-}
logException
  :: (MonadWebError m, MonadCatch m, WithBCDLog m)
  => Text -- ^ Application name
  -> m a  -- ^ Action to run
  -> m a
logException appName =
  withFrozenCallStack $ logExceptionWith appName defaultExceptionFormatter
